# 2.0 Управление порядком выполнения программы
## Псевдо-код
Представим - злой начальник дал нам очередное задание. Ему нужна программа, которая будет говорить, является ли некоторое число четным или нет.
Подумав, вы в голове придумывайте примерно такой алгоритм
```
    считать число
    если число четное
        вывести "да"
    иначе
        вывести "нет"
```
Такое представление алгоритма еще называют псевдо-кодом, потому что мы описываем алгоритм конструкциями, похожими на конструкции языка программирования. Но стоит заметить, что псевдо-код может являться намного менее формальным, и в нем могут присутсвовать предложения вроде
```
    // Здесь приведен алгоритм нахождения человека в адресной книжке
    открыть книжку посередине
    если фамилия человека на этой странице
        мы нашли его
    иначе если его фамилия правее
        искать его в правой части
    иначе если его фамилия левее
        искать его в левой части
    иначе
        человека нету в данной книжке
```
Понятно, что слова вроде **искать его в правой части** никак не объясняют, как мы собираемся реализовывать этот поиск - они лишь объясняют основную идею. Этим и хорошо псевдо-код - мы можем описывать суть алгоритмов, не вдаваясь в подробности их реализации на каком-то конкретном языке программирования.

## Если, иначе
Итак, как же нам реализовать наш первый псевдокод в программе?
В языке С слову **если** соответсвует ключевое слово **if**, а слову **иначе**  - else.
Например, чтобы выполнить какой-то кусок программы только, если определенное число больше нуля
```c
if(a > 0){
    // выполнить если а больше нуля
} else {
    // выполнить иначе, т.е. если а не больше нуля (a <= 0)
}
```
А как же проверить, что введенное число четное? Для этого нужно немного вспомнить математику. Четное число при делении на 2 всегда дает остаток 0, а нечетное 1.
Как мы уже знаем, остаток от деления находится операцией %.
Таким образом наш первый псевдо-код можно реализовать так
```c
#include <stdio.h>

int main(){
    int number;

    printf("Введите ваше число\n"); // Небольшая подсказка пользователю
    scanf("%d", &number);

    if(number % 2 == 0){
        printf("Число %d четное!\n", number);
    } else {
        printf("Число %d нечетное!\n", number);
    }
}
```
Подумайте (или испытайте), всегда ли работает наша программа? Будет ли она работать если пользователь введет 0? Отрицательное число? Что если пользователь введет букву?

## Множественные условия

Для примера напишем решим еще одну простую задачу. Нужно по введенным координатам точки определить, в какой из 4 частей плоскости лежит точка.
Для начала набросаем основной алгоритм 
```
пользователь вводит два числа, х и у
если х > 0 и у > 0
    вывести "Первая плоскость"
иначе
    если x < 0 и у > 0
        вывести "Вторая плоскость"
    иначе
        если x < 0 и у < 0
            вывести "Третья плоскость"
        иначе
            если x > 0 и y < 0
                вывести "Четвертая плоскость"
```
Как видите, конструкции, которые мы уже знаем, позволяют нам описать решение, однако сам текст программы выглядит не очень элегантно. Последняя строчка имеет аж 4 отступа, что часто говорит о нехорошо написанном коде. Если вы посмотрите на него внимательно, вы заметите часто повторяющуюся конструкцию 
```
иначе
    если
```
Действительно, ее можно заменить просто на 
```
иначе если
```
Перепишем наш код, используя новую конструкцию
```
пользователь вводит два числа, х и у
если х > 0 и у > 0
    вывести "Первая четверть"
иначе если x < 0 и у > 0
    вывести "Вторая четверть"
иначе если x < 0 и у < 0
    вывести "Третья четверть"
иначе если x > 0 и y < 0
    вывести "Четвертая четверть"
```
Наш код теперь выглядит компактнее и проще читается. Теперь переведем наш псевдо-код в программу С
```c
#include <stdio.h>
int main(void){
    int x, y;
    scanf("%d %d", &x, &y);

    if(x > 0 && y > 0){
        printf("Первая четверть\n");
    } else if(x < 0 && y > 0){
        printf("Вторая четверть\n");
    } else if(x < 0 && y < 0){
        printf("Третья четверть\n");
    } else if(x > 0 && y < 0){
        printf("Четвертая четверть\n");
    }

    return 0;
}
```
Как видите, **если** и **иначе** так и остаются **if** и **else**.

## Логические операторы

В предыдущем тексте вы заметили знак **&&**, который стоит на месте **и**. Дейсвительно, двойной амперсант означает **Логическое И**. Это один из операторов булевой алгебры. Его значение равно правде, только если оба его операнда равны правде (т.е. правда && правда = правда, в остальном случае ложь). Хорошим примером для него может служить рецепт приготовления блюда - для омлета вам понадобятся яйца **и** молоко. Если хотя бы одного из компонентом нету, омлета вы уже не получите.

В противовес **и** существует оператор **или*. Его значение равно правде, если хотя бы один из его операндом равен правде. Примером могут служить какие-нибудь желания - хочу научиться играть на гитаре **или** съездить в отпуск **или** новую NVIDIA Quadro FX 5800. Вы будете счастливы, выполнись хотя бы одно из этих условий, однако выполнение двух или более условий также оставят вас счастливыми. Подробнее про булевую алгебру можно почитать [тут](FIXME).

Возвращаясь к нашей проблеме, что означет эта запись?
```c
if(x > 0 && y > 0){
    // код
}
```
Это означает, что код будет выполняться только, если х > 0 **и** y > 0. Если хотя бы одно из этих условий не верно (x < 0, y < 0), код выполняться не будет.

Выполните нашу программу и вводите в нее разные координаты. Всегда ли вы получаете нужный ответ?

## У ВАС ТУТ ОШИБКА
Внимательный читатель мог заметить, что мы не учли некоторые случаи. Что будет, если пользователь в одной из координат задаст 0? Программа сломается? Или выведет какой-то ответ? Или ничего не выведет и завершится? Проверьте это сами, если уже не сделали (но сначала попробуйте ответить устно).

Исправить эту ошибку мы можем, определяя, лежит ли точка на одной из осей (т.е. равна ли одна из координат 0). Однако мы займемся этим в **Главе 3 Функции**, поскольку это потребует некого усложнения кода.