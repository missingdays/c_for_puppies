# 3.0 Функции
## Вступление
Вернемся к нашему заданию про определение положения точки. Мы обнаружили проблему, что при попадании ее на одну из осей наша програма не выводила совсем ничего. Исправим это, дополнив наш код.

```c
#include <stdio.h>
int main(void){
    int x, y;
    scanf("%d %d", &x, &y);

    if(x == 0){
    	printf("Точка лежит на оси Y\n");
    } else if(y == 0){
    	printf("Точка лежит на оси X\n");
    } else if(x > 0 && y > 0){
        printf("Первая четверть\n");
    } else if(x < 0 && y > 0){
        printf("Вторая четверть\n");
    } else if(x < 0 && y < 0){
        printf("Третья четверть\n");
    } else if(x > 0 && y < 0){
        printf("Четвертая четверть\n");
    }

    return 0;
}
```

Хорошо. Однако взглянем на этот код с другой стороны. Как он будет выглядеть для человека, который в первый раз взглянет на него? Он увидит множество сравнений с нулем, разобраться в котором не так то просто. Более того, что, если мы захотим использовать такую логику где-то еще? Нам придется копировать весь код целиком. Попробуем немного абстрагироваться от иксов и игреков, и подумать, что же мы конкретно проверяем в каждом условии. В этой строчке `if(x == 0)` нас на самом деле интересует, находится ли точка на оси Y, однако только из кода это мало понятно. Сколько времени вам потребуется, чтобы понять, что имено проверяет это условие `else if(x < 0 && y > 0)`? И это при том, что вы знаете контекст, в котором оно исполняется. На самом деле мы хотим, чтобы наш код читался примерно как `if(точка лежит на оси Y){ ... }`. И мы можем это сделать, введя новое понятие - функция.

## Понятие функции

Вспомним, что же такое функция в математике. Функция - это такой математический объект, который принимает одну или несколько переменных, что-то с ними делает и возвращает результат. Например f(x) = x + 2 принимает один аргумент, увеличивает его на два и возвращает. В языке Си это выглядит немного посложнее, и мы попробуем во всем разобраться. Объявим такую функцию и назовем ее `addTwo`.
```c
int addTwo(int x){
	return x+2;
}
```
Сначала нам нужно определить, что данная функция будет принимать. addTwo принимает одно целое число `int`. Это написано в круглых скобочках. Дальше, нам нужно определить, что она будет возвращать. Это тоже `int`, что написано уже перед именем функции `addTwo`. Внутри фигурных скобочек идет так называемое тело функции, в котором происходит вся работа с ней. Ключевое слово `return` означает `вычисли вот это значение и верни`. Теперь посмотрим, как с этой функцией работать.
```c
int main(){
	int a = 10;
	int b = addTwo(a); // b == 12
	b = addTwo(b); // b == 14
	b = addTwo(2); // b == 4
}
```
Теперь становится понятно, что же такое этот `main`. Это такая же функция, разве что не принимающая никаких аргументов (на самом деле в нее передаются аргументы командной строки, но об этом позже). Каждая программа, которая выполняется как главная, должна иметь такую функцию `main`, что и означает "главная, основная".

Сейчас не совсем понятно, зачем так явно писать, какого типа аргументы функция принимает и какого типа возвращает. Почему компилятор не может сообразить этого сам? Начать стоит с того, что язык программирования Си является статически типизированным. Это страшное словосочетание означает, что типы всех переменных определяются еще на этапе компиляции, когда наш код только транслируется в ассемблер, машинный код или любой другой язык нижнего уровня. В отличии от этого, в языках с динамической типизацией тип переменной определяется только во время непосредственного выполнения кода. Это избавляет разработчика от нужды везде и явно писать, что эта переменная это число, эта буква, а эта - строка. Однако это же и влечет за собой много проблем. При работе с числом он вдруг может превратиться в строку, и наша программа радостно упадет и выдаст ошибку, выследить которую не так-то просто.

Таким образом, компилятор гарантирует нам, что если мы говорим, что функция принимает целое число, то в нее и будет передано целое число, а не строка, другая функция или динозавр. Однако следует быть осторожным. Мы ведь помним, что все одиночные буквы на самом деле являются обычным числом, и компилятор относится к ним как к обычным числам - складывает их, перемножает, передает в функции как числа. Поэтому статическая типизация вовсе не избавляет от нужды вдумчиво писать код - она лишь избавляет от некоторых глупых ошибок.

Следует сказать, что функции в языке Си могут влиять на переменные, которые непосредственно в саму функцию не входят. Например, так можно реализовать простой счетчик, который будет сообщать, сколько раз его уже вызывали.

```c
int count = 0;

int counter(){
	count = count + 1;
	return count;
}

int main(){
	printf("%d\n", counter()); // 1
	printf("%d\n", counter()); // 2
	printf("%d\n", counter()); // 3
```

## Перепишем пример

Вернемся к нашему примеру. Преставим, что пользователь должен вводить координаты не одной точки, а двух или больше. Каждый раз писать 10 строк if..else выглядит не очень хорошей затеей. Давайте создаем функцию, которая будет делать работу по проверке того, в какую область или на какую ось попадает точка.

Будем обозначать каждую возможную позицию числами для простоты. Четверти пронумеруем от 1 до 4, ось X будет числом 5, ось Y - 6. На всякий непредвиденный случай, если вдруг ни один if не выполнился (может ли быть так сейчас?), вернем 0. 
```
int get_point_position(int x, int y){
    if(x == 0){
        return 6;
    } else if(y == 0){
        return 5;
    } else if(x > 0 && y > 0){
        return 1;
    } else if(x < 0 && y > 0){
        return 2;
    } else if(x < 0 && y < 0){
        return 3;
    } else if(x > 0 && y < 0){
        return 4;
    }

    return 0;
}
```

Теперь воспользуемся ей в main.

```c
... // здесь определение функции get_point_position
int main(void){
    int x1, y1;
    scanf("%d %d", &x1, &y1);
    printf("%d\n", get_point_position(x1, y1));

    int x2, y2;
    scanf("%d %d", &x2, &y2);
    printf("%d\n", get_point_position(x2, y2));

    return 0;
}
```

Сейчас на экран будут выводиться числа, и пользователь программы вряд ли поймет, что они значат. Напишем еще одну функцию, которая будет печатать осмысленный результат функции get_point_position. Возвращать она будет ничего, поэтому перед именем ставим *void*.

```c
... // здесь определение функции get_point_position
void print_point_position(int x, int y){
    int pos = get_point_position(x, y);

    if(pos == 5){
        printf("Точка лежит на оси Y\n");
    } else if(pos == 6){
        printf("Точка лежит на оси X\n");
    } else if(pos == 1){
        printf("Первая четверть\n");
    } else if(pos == 2){
        printf("Вторая четверть\n");
    } else if(pos == 3){
        printf("Третья четверть\n");
    } else if(pos == 4){
        printf("Четвертая четверть\n");
    } else {
        printf("Неизвестная позиция\n");
    }
}
```

```c
... // здесь определение функции get_point_position
... // здесь определение функции print_point_position
int main(void){
    int x1, y1;
    scanf("%d %d", &x1, &y1);
    print_point_position(x1, y1);

    int x2, y2;
    scanf("%d %d", &x2, &y2);
    print_point_position(x2, y2);

    return 0;
}
```

Заметьте, что определение функции get_point_position должно стоять строго выше того места, где мы его используем, иначе компилятор начнет ругаться. Так происходит потому, что если мы заранее не объявили *get_point_position*, то дойдя до его вызова, компилятор не будет знать, что же такое этот *get_point_position*. 

Но что делать, если из функции *A* мы вызываем *B*, а из функции *B* мы вызываем *A*? Мы не можем одновременно поместить *A* выше *B* и *B* выше *A*. Для этого мы можем объявить лишь заголовок функции, указав в нем все возвращаемые и принимаемые значения, а само тело (реализацию) писать ниже.

```c
int A();
char B(int a);

int A(){
    char c = B(10);
}

char B(int a){
    int d = A();
}
```

Почему и как это работает "под капотом" мы разберем в дальнейших главах.

Больше о функциях сказать особо нечего. Главное набить с ними руку на практике, и они станут отличными помощниками в быстром написании хорошего кода.
