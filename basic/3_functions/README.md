# 3.0 Функции
## Вступление
Вернемся к нашему заданию про определение положения точки. Мы обнаружили проблему, что при попадании ее на одну из осей наша програма не выводила совсем ничего. Исправим это, дополнив наш код.

```c
#include <stdio.h>
int main(void){
    int x, y;
    scanf("%d %d", &x, &y);

    if(x == 0){
    	printf("Точка лежит на оси Y");
    } else if(y == 0){
    	printf("Точка лежит на оси X");
    } else if(x > 0 && y > 0){
        printf("Первая четверть\n");
    } else if(x < 0 && y > 0){
        printf("Вторая четверть\n");
    } else if(x < 0 && y < 0){
        printf("Третья четверть\n");
    } else if(x > 0 && y < 0){
        printf("Четвертая четверть\n");
    }

    return 0;
}
```

Хорошо. Однако взглянем на этот код с другой стороны. Как он будет выглядеть для человека, который в первый раз взглянет на него? Он увидит множество сравнений с нулем, разобраться в котором не так то просто. Более того, что, если мы захотим использовать такую логику где-то еще? Нам придется копировать весь код целиком. Попробуем немного абстрагироваться от иксов и игреков, и подумать, что же мы конкретно проверяем в каждом условии. В этой строчке `if(x == 0)` нас на самом деле интересует, находится ли точка на оси Y, однако только из кода это мало понятно. Сколько времени вам потребуется, чтобы понять, что имено проверяет это условие `else if(x < 0 && y > 0)`? И это при том, что вы знаете контекст, в котором оно исполняется. На самом деле мы хотим, чтобы наш код читался примерно как `if(точка лежит на оси Y){ ... }`. И мы можем это сделать, введя новое понятие - функция.

## Понятие функции

Вспомним, что же такое функция в математике. Функция - это такой математический объект, который принимает одну или несколько переменных, что-то с ними делает и возвращает результат. Например f(x) = x + 2 принимает один аргумент, увеличивает его на два и возвращает. В языке Си это выглядит немного посложнее, и мы попробуем во всем разобраться. Объявим такую функцию и назовем ее `addTwo`.
```c
int addTwo(int x){
	return x+2;
}
```
Сначала нам нужно определить, что данная функция будет принимать. addTwo принимает одно целое число `int`. Это написано в круглых скобочках. Дальше, нам нужно определить, что она будет возвращать. Это тоже `int`, что написано уже перед именем функции `addTwo`. Внутри фигурных скобочек идет так называемое тело функции, в котором происходит вся работа с ней. Ключевое слово `return` означает `вычисли вот это значение и верни`. Теперь посмотрим, как с этой функцией работать.
```c
int main(){
	int a = 10;
	int b = addTwo(a); // b == 12
	b = addTwo(b); // b == 14
	b = addTwo(2); // b == 4
}
```
Теперь становится понятно, что же такое этот `main`. Это такая же функция, разве что не принимающая никаких аргументов (на самом деле в нее передаются аргументы командной строки, но об этом позже). Каждая программа, которая выполняется как главная, должна иметь такую функцию `main`, что и означает "главная, основная".

Сейчас не совсем понятно, зачем так явно писать, какого типа аргументы функция принимает и какого типа возвращает. Почему компилятор не может сообразить этого сам? Начать стоит с того, что язык программирования Си является статически типизированным. Это страшное словосочетание означает, что типы всех переменных определяются еще на этапе компиляции, когда наш код только транслируется в ассемблер, машинный код или любой другой язык нижнего уровня. В отличии от этого, в языках с динамической типизацией тип переменной определяется только во время непосредственного выполнения кода. Это избавляет разработчика от нужды везде и явно писать, что эта переменная это число, эта буква, а эта - строка. Однако это же и влечет за собой много проблем. При работе с числом он вдруг может превратиться в строку, и наша программа радостно упадет и выдаст ошибку, выследить которую не так-то просто.

Таким образом, компилятор гарантирует нам, что если мы говорим, что функция принимает целое число, то в нее и будет передано целое число, а не строка, другая функция или динозавр. Однако следует быть осторожным. Мы ведь помним, что все одиночные буквы на самом деле являются обычным числом, и компилятор относится к ним как к обычным числам - складывает их, перемножает, передает в функции как числа. Поэтому статическая типизация вовсе не избавляет от нужды вдумчиво писать код - она лишь избавляет от некоторых глупых ошибок.

Следует сказать, что функции в языке Си могут влиять на переменные, которые непосредственно в саму функцию не входят. Например, так можно реализовать простой счетчик, который будет сообщать, сколько раз его уже вызывали.

```c
int count = 0;

int counter(){
	count = count + 1;
	return count;
}

int main(){
	printf("%d\n", counter()); // 1
	printf("%d\n", counter()); // 2
	printf("%d\n", counter()); // 3
```

Больше о функциях сказать особо нечего. Главное набить с ними руку на практике, и они станут отличными помощниками в быстром написании хорошего кода.
